# docker-compose ASP.NET with MS-SQL

TL/DR: This document describes how to setup docker containers running ASP.NET Core and MS-SQL, 
orchestrated using `docker-compose`.

Tech stack:

- ASP.NET Core (v5.x) -> .NET REST API backend
- EntityFramework Core (v5.x) -> OR-Mapper
- Swashbuckle (v5.6.x) -> OpenAPI / Swagger
- MS-SQL Server 2019 -> Database
- Host OS: linux

We will create 2 docker containers:

- ASP.NET Core WebAPI
- MS-SQL

## Prerequisites

Basic knowledge / understanding of:

- dotnet web-api
- EntityFramework (including migrations)
- Docker

## Step 1: Create a WebAPI project using the default template

`dotnet new webapi -o DemoWebApplication`

## Step 2: Create a solution file

- `dotnet new sln`
- `dotnet sln add DemoWebApplication/DemoWebApplication.csproj`

## Step 3: Simplify default template and add new model, controller, and OpenAPI

- Remove all `Weatherforecst` references and files.
- Add folder `Models`, add class `Notes` to folder.
- Add new controller `NotesController` with `Get` and `Seed` methods.
- Add new controller `HealthCheckController`.
- Add OpenAPI (`Swashbuckle`) to `Startup.cs`.
- Deactivate https redirection in `Startup.cs` (HTTPS certificates in linux docker containers is another challenge, not covered here).
- Test application by visiting:
  - `http://localhost:5000/index.html` -> Swagger
  - `http://localhost:5000/notes` -> "HTTP-GET" should return all notes
  - and `http://localhost:5000/healthcheck` -> should return "ok"

## Step 4: Create docker container for web application

Create a file `Dockerfile` with the following content:

```docker
FROM mcr.microsoft.com/dotnet/sdk:5.0 AS build
WORKDIR /src

# Copy csproj aand restore nuget packages
COPY "DemoWebApplication.csproj" "DemoWebApplication/"
RUN dotnet restore "DemoWebApplication/DemoWebApplication.csproj"

# Copy everything else and publish (publish includes build)
COPY . "DemoWebApplication"
WORKDIR "/src/DemoWebApplication"
RUN dotnet publish "DemoWebApplication.csproj" -c Development -o /app/publish

# Build runtime image
FROM mcr.microsoft.com/dotnet/aspnet:5.0
WORKDIR /app
COPY --from=build /app/publish .
ENTRYPOINT ["dotnet", "DemoWebApplication.dll"]
```

This is the default docker file for ASP.NET as recommended by Docker 
(see [Create a Dockerfile for an ASP.NET Core application](https://docs.docker.com/samples/dotnetcore/#create-a-dockerfile-for-an-aspnet-core-application) for details). 

The above `Dockerfile` is just an example. Feel free to tweak it to your needs.

Add the `DockerDefaultTargetOS` element to the `DemoWebApplication.csproj` file (TODO: Check if this is necessary):

```xml
<PropertyGroup>
  <TargetFramework>net5.0</TargetFramework>
  <DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
</PropertyGroup>
```

We can start the web application docker container using this script:

```sh
IMAGE_NAME=demowebapp1
CONTAINER_NAME=demo_container

## NOTE: docker/aspnet default internal port is 80
PORT_INTERNAL_DOCKER=80
PORT_EXTERNAL=5000

docker run \
  -it \
  --rm \
  -p ${PORT_EXTERNAL}:${PORT_INTERNAL_DOCKER} \
  --name ${CONTAINER_NAME} \
  ${IMAGE_NAME}
```

Verify by visiting `http://localhost:5000/healthcheck`. Once we have checked that the
application works inside the docker container, we can remove the docker container (`docker kill
DOCKER_ID`).

## Step 5: Create database manually

Our database will be running in a docker container. 

The following command will start a docker container running mssql-2019:

```sh
docker run \
  -e 'ACCEPT_EULA=Y' \
  -e 'SA_PASSWORD=Str0ngPa$$w0rd' \
  -p 1433:1433 \
  -v mssql-demo:/var/opt/mssql \
  -d mcr.microsoft.com/mssql/server:2019-latest
```

Options explained:

- `-e` sets environment variables to be used inside the docker container (note the strong password
  restrictions by MS-SQL...)
- `-p <HOST_PORT>:<CONTAINER_PORT>` configures the ports to be used on the host and inside the
  docker container
- `-v <VOLUME_NAME>:<LOCATION_IN_CONTAINER>` **configures a docker volume to persist data**
- `-d <DOCKER_IMAGE_NAME>` name of the docker image to be used

Verify the container started successfully and didn't crash using `docker ps -a`: 
The status column should NOT be `Excited`.

Stop and remove the container once everything works: `docker stop DOCKER_ID` and `docker rm
DOCKER_ID`.

## Step 6: Setup EF-Core, create and apply db migration

- Create custom DbContext (`AppDbContext`)
- Add configuration to `Startup.cs` -> `ConfigureServices`
- Add a connectionString section to `appsettings.json`. Use `localhost` as server name.
  Example: `"AppDbContext": "Server=localhost;Database=AppDbContext;User=sa;Password=Str0ngPa$$w0rd;"`. 
  **IMPORTANT: We will have to change `localhost` later when using `docker-compose`!**
- Create migration: `dotnet ef migrations add My-Initial-Migration`. This will create a new folder
  `Migrations` with autogenerated C# code. 
- Start the ms-sql docker container manually (see Step 4)
- The generated migration is applied to the database using `dotnet ef database update`.

Using a tool of your choice verify that the migration has been applied to the database. The database
should now contain 2 tables: `__EFMigrationsHistory` and `Notes`. The table `__EFMigrationsHistory`
should contain 1 entry with `MigrationId` `<Date_of_migration>_My-Initial-Migration`.

We can now remove the ms-sql docker container, restart it, and confirm the using a **docker volume**
persisted our data in the database even though the docker container was recycled.

Optional: Add some data entries to the `Notes` table manually, so we have some values to check later.

## Step 7: Wiring things up using docker compose

Before moving on, ensure that all docker containers are removed.

Instead of manually executing both docker containers using `docker run...`, we will 
use `docker-compose` to orchestrate both containers from a single config file. 
Save the following content to a file named `docker-compose.yml`:

```yaml
version: '3.9'

services:
  
    webapi:
        image: ${DOCKER_REGISTRY-}demowebapp1
        ports:
          - "5000:80"
        build:
          context: .
          dockerfile: Dockerfile
        depends_on:
          - db
              
    db:
      image: "mcr.microsoft.com/mssql/server:2019-latest"
      environment:
        ACCEPT_EULA: "Y"
        SA_PASSWORD: Str0ngPa$$w0rd
      ports:
        - "1433:1433"
      volumes:
        - mssql-demo:/var/opt/mssql

volumes: 
  mssql-demo:
    external: true
```

IMPORTANT: Ensure that the connection string in `appsettings.json` uses 
the same database name as in the `docker-compose.yml` file (here: `db`)!

Whenever we make changes to our code we have to execute `docker build`. 
`docker-compose` has a helpful command for this: 
`docker-compose build` will check if there are any changes requiring a rebuild 
of the docker container.

Finally, we can start `docker-compose` using the command `docker-compose up`.

Verify by visiting `http://localhost:5000/notes`: It should return a JSON string 
containing the few manual entries we added to the database at the end of 
Step 6. In case no data was created, we can visit the Swagger site 
at `http://localhost:5000/index.html` and invoke the POST method to seed some 
demo data into the database.


