# docker compose ASP.NET with MS-SQL

Howto setup docker containers running ASP.NET Core and MS-SQL, orchestrated using docker compose.

Tech stack:

- ASP.NET Core (v5.x)
- EntityFramework Core (v5.x)
- MS-SQL Server 2019
- Host OS: linux

We will create 2 docker containers:

- ASP.NET Core WebAPI
- MS-SQL

## Step 1: Create a WebAPI project using the default template

`dotnet new web-api -o DemoWebApplication`

## Step 2: Create a solution file

- `dotnet new sln`
- `dotnet sln add DemoWebApplication/DemoWebApplication.csproj`

## Step 3: Simplify default template and add new model, controller, and OpenAPI

- Remove all `Weatherforecst` references and files.
- Add folder `Models`, add class `Notes` to folder.
- Add new controller `NotesController`.
- Add new controller `HealthCheckController`.
- Add OpenAPI (`Swashbuckle`).
- Test application by visiting `http://localhost:5000/notes` and `http://localhost/healthcheck`.

## Step 4: Create docker container for web appliction

Create a file `Dockerfile` with the following content:

```docker
FROM mcr.microsoft.com/dotnet/aspnet:5.0 AS base
WORKDIR /app

FROM mcr.microsoft.com/dotnet/sdk:5.0 AS build
WORKDIR /src
COPY ["DemoWebApplication.csproj", "DemoWebApplication/"]
RUN dotnet restore "DemoWebApplication/DemoWebApplication.csproj"
COPY . "DemoWebApplication"
WORKDIR "/src/DemoWebApplication"
RUN dotnet build "DemoWebApplication.csproj" -c Development -o /app/build

FROM build AS publish
RUN dotnet publish "DemoWebApplication.csproj" -c Development -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "DemoWebApplication.dll"]
```

This is the default docker file as recommended by Microsoft. Please see the official docs for
further explanations.

Add the `DcokerDefaultTargetOS` element to the `DemoWebApplication.csproj` file:

```xml
<PropertyGroup>
  <TargetFramework>net5.0</TargetFramework>
  <DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
</PropertyGroup>
```

We can start the web application docker container using this script:

```sh
IMAGE_NAME=demowebapp1
CONTAINER_NAME=demo_container

## NOTE: docker/aspnet default internal port is 80
PORT_INTERNAL_DOCKER=80
PORT_EXTERNAL=5000

docker run \
  -it \
  --rm \
  -p ${PORT_EXTERNAL}:${PORT_INTERNAL_DOCKER} \
  --name ${CONTAINER_NAME} \
  ${IMAGE_NAME}
```

Verify by visiting `http://localhost:5000/healthcheck` in browser. Once we have checked that the
application works inside the docker container, we can remove the docker container (`docker kill
DOCKER_ID`).

## Step 5: Create database manually

Our database will be running in a docker container. 

The following command will start a docker container running mssql-2019:

```sh
docker run \
  -e 'ACCEPT_EULA=Y' \
  -e 'SA_PASSWORD=Str0ngPa$$w0rd' \
  -p 1433:1433 \
  -v mssql-demo:/var/opt/mssql \
  -d mcr.microsoft.com/mssql/server:2019-latest
```

Options explained:

- `-e` sets environment variables to be used inside the docker container (note the strong password
  restrictions by MS-SQL...)
- `-p <HOST_PORT>:<CONTAINER_PORT>` configures the ports to be used on the host and inside the
  docker container
- `-v <VOLUME_NAME>:<LOCATION_IN_CONTAINER>` configures a docker volume to persist data
- `-d <DOCKER_IMAGE_NAME>` name of the docker image to be used

Verify the container started successfully and didn't crash using `docker ps -a`: The status column should NOT be
`Excited`.

Stop and remove the container once everything works: `docker stop DOCKER_ID` and `docker rm
DOCKERID`.

## Step 6: Setup EFCore, create and apply db migration

- Create custom DbContext (`AppDbContext`)
- Add configuration to `Startup.cs` -> `ConfigureServices`
- Add a connectionString section to `appsettings.json`. Use `localhost` as server name.
- Create migration: `dotnet ef migrations add My-Initial-Migration`. This will create a new folder
  `Migrations` with autogenerated C# code. 
- Start the ms-sql docker container manually (see Step 4)
- The generated migration is applied to the database using `dotnet ef database update`.

Using a tool of your choice verify that the migration has been applied to the database. The database
should now contain 2 tables: `EF_Migration_History` and `Notes`. The table `EF_Migration_History`
should contain 1 entry with name `My-Initial-Migration`.

We can now remove the ms-sql docker container, restart it, and confirm the using a docker volume
persisted our data in the database even though the docker container was recycled.

Add 1 or 2 data entries to the `Notes` table manually, so we have some values to check later.

## Step 7: Wiring things up using docker compose

Before moving on, ensure that all docker containers are removed.

Instead of manually executing both docker containers using `docker run...`, we will use `docker
compose` to orchestrate both containers from a single config file. Save the following content to a
file named `docker-compose.yml`:

```yaml
version: '3.9'

services:
  
    webapi:
        image: ${DOCKER_REGISTRY-}demowebapp1
        ports:
          - "5000:80"
        build:
          context: .
          dockerfile: Dockerfile
        depends_on:
          - db
              
    db:
      image: "mcr.microsoft.com/mssql/server:2019-latest"
      environment:
        ACCEPT_EULA: "Y"
        SA_PASSWORD: Str0ngPa$$w0rd
      ports:
        - "1433:1433"
      volumes:
        - mssql-demo:/var/opt/mssql

volumes: 
  mssql-demo:
    external: true
```

Ensure that the connection string in `appsettings.json` uses the same database name as in the
`docker-compose.yml` file (here: `db`)!

We now have to rebuild the web-docker image (`docker build -t demowebapp1 .`).

Finally, we can start docker compose using the command `docker-compose up`.

Verify by visiting `http://localhost/notes`: It should return a JSON string containing the few
manual entries we added to the database at the end of Step 6.

